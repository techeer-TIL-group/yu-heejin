> Race Condition이란 여러 개의 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과값이 달라질 수 있는 현상이다.
> 

똑같은 코드를 100번 돌리면 실행 결과가 항상 같아야 하는데, 경쟁 상태가 발생하면 결과가 달라질 수 있다.

이러한 문제를 방지하기 위해 공유 메모리를 쓰는 프로세스끼리 동기화를 해줘야 한다.

정리하자면 공유 메모리를 쓰는 프로세스끼리는 경쟁상태가 발생할 수 있는데, 이에 대한 해결책이 동기화다.

## 경쟁 상태(Race Condition)

- 공유 자원에 여러 프로세스나 스레드가 동시에 접근을 시도할 때, **접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태**

## Race Condition이 발생하는 경우

### 유저 모드와 커널 모드

- 유저 모드
    - 사용자가 접근할 수 있는 영역을 제한적으로 두고, 프로그램의 자원에 함부로 접근하지 못하는 모드
    - 코드를 작성하고 프로세스를 실행하는 행위를 할 수 있다.
- 커널 모드
    - 모든 자원(CPU, 메모리 등) 접근, 명령 가능한 모드
- 프로세스 간에는 주소 공간이 독립적이지만, **커널에 있는 자원은 여러 프로세스가 공유할 수 있기 때문에 주로 유저 모드보다 커널 모드일 때 경쟁 상태가 발생한다.**

### 커널 작업을 수행하는 중에 인터럽트 발생

- 커널 모드에서 데이터를 불러 작업을 수행하다 인터럽트가 발생하면 같은 데이터를 조작하게 된다.
- 따라서 **커널모드에서 작업을 수행할 때는 인터럽트가 발생되지 않도록 설정하면 된다.**

### 프로세스가 시스템 콜(System call)을 하여 커널 모드로 진입하여 작업을 수행하던 중 문맥 교환(Context Switch)이 발생

- 프로세스 A가 커널 모드에서 데이터를 작업하는 도중 문맥 교환이 일어나면 같은 프로세스 B에서 같은 데이터를 조작하게 된다.
    - 이 때 프로세스 2의 작업은 반영되지 않게 된다.
- 이 경우는 **프로세스가 커널 모드에서 작업하는 경우 CPU 제어권을 뺏지 않도록 하면 된다.**

### 멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근할 때

- 멀티 프로세스 환경에서 **2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하는 경우도 문제가 생길 수 있는데**, 커널 내부에 있는 공유 데이터에 접근할 때마다 lock/unlock을 해서 해결할 수 있다.

## 참고 자료

- https://velog.io/@kku64r/deadlock
- [https://parkmuhyeun.github.io/etc/operating system/2022-09-08-Race-Condition/](https://parkmuhyeun.github.io/etc/operating%20system/2022-09-08-Race-Condition/)
- https://iredays.tistory.com/125
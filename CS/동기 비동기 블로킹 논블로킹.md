## 알아두면 좋은 용어

### 제어권

- 제어권은 자신(함수)의 코드를 실행할 권리같은 것이다.
- 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려준다.

### 결과값을 기다린다

- A함수에서 B함수를 호출했을 때, A함수가 B함수의 결과값을 기다리느냐의 여부를 의미한다.

## 동기/비동기, 블로킹/논블로킹

- 동기/비동기는 요청한 작업에 대해 완료 여부를 신경써서 작업을 순차적으로 수행할지 아닌지에 대한 관점이다.
- 블로킹/논블로킹은 단어 그대로 현재 작업이 차단되느냐 아니냐에 따라 다른 작업을 수행할 수 있는지에 대한 관점이다.
- 일반적으로 자바스크립트의 `setTimeout()` 함수를 일반적으로 비동기 함수라고 부르지만 동시에 논블로킹 함수이기도 하다.
    - 우리가 편의상 부르는 자바스크립트 비동기 함수는 사실 비동기 + 논블로킹 함수인 것이다.

## Blocking(블로킹)과 Non-Blocking(논블로킹)

> 블로킹과 논블로킹은 A함수가 B함수를 호출했을 때, 제어권을 어떻게 처리하느냐에 따라 달라진다.
> 

> 동기/비동기가 전체적인 작업에 대한 순차적인 흐름 유무라면, 블로킹/논블로킹은 **전체적인 작업의 흐름 자체를 막냐 안 막냐**로 볼 수 있는 것이다.
> 

### 블로킹

![Untitled](https://velog.velcdn.com/images%2Fnittre%2Fpost%2F8cdc0a02-d469-47d5-96c8-f6aeef204eb7%2Fimage.png)

블로킹은 A함수가 B함수를 호출하면, **제어권을 A가 호출한 B 함수에 넘겨준다.**

1. A함수가 B함수를 호출하면 B에게 제어권을 넘긴다.
2. 제어권을 넘겨받은 B는 열심히 함수를 실행한다.
    1. **A는 B에게 제어권을 넘겨주었기 때문에 함수 실행을 잠시 멈춘다.**
3. B함수는 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.

### 논블로킹

![Untitled](https://velog.velcdn.com/images%2Fnittre%2Fpost%2Fc839fc04-1788-4063-ab38-b0d4a312dbf4%2Fimage.png)

논블로킹은 A함수가 B함수를 호출해도 **제어권은 그대로 자신이 가지고 있는다.**

1. A함수가 B함수를 호출하면, B함수는 실행되지만 **제어권은 A함수가 그대로 가지고 있는다.**
2. A함수는 계속 제어권을 가지고 있기 때문에 **B함수를 호출한 이후에도 자신의 코드를 계속 실행한다.**

## Synchronous(동기)와 Asynchronous(비동기)

> 동기와 비동기의 차이는 호출되는 함수의 작업 완료 여부를 신경쓰는지의 여부의 차이이다.
> 

### 동기

- 함수 A가 함수 B를 호출한 뒤, **함수 B의 리턴값을 계속 확인하면서 신경쓰는 것**이 동기이다.
- 요청한 작업에 대해 **완료 여부를 따져 순차대로 처리하는 것을 의미한다.**

### 비동기

- 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서, 함수 B의 작업이 완료되면 콜백 함수를 실행한다.
    - **함수 A는 함수 B를 호출한 후로 함수 B의 작업 완료 여부에는 신경쓰지 않는다.**
- 동기와 달리 요청한 작업에 대해 **완료 여부를 따지지 않기 때문에 자신의 다음 작업을 그대로 수행하게 된다.**

### 비동기의 성능 이점

<img width="698" alt="스크린샷 2024-05-09 오후 9 45 53" src="https://github.com/yu-heejin/coding-test/assets/96467030/58418f94-55c4-43ac-a71c-dc21706a8f47">


요청한 작업에 대해 완료 여부를 신경쓰지 않고 자신의 그 다음 작업을 수행하는 것은, I/O 작업과 같은 느린 작업이 발생할 때, **기다리지 않고 다른 작업을 처리하면서 동시에 처리해 멀티 작업을 진행할 수 있다.**

## 비동기와 논블로킹 개념 차이

```jsx
console.log("시작");

setTimeout(() => {
	console.log("1초 후에 실행됩니다.");
}, 1000);

console.log("끝");

// 출력 결과
시작
끝
1초 후에 실행됩니다!
```

- 위 코드를 보면, 출력 순서와 정의된 코드 라인 순서가 맞지 않는다.
    - 이는 `setTimeout` 함수에 대해 타이머 작업 완료 여부를 신경쓰지 않고 바로 그 다음 콘솔 작업을 수행했기 때문이다.
    - 그리고 `setTimeout` 함수의 타이머 작업 완료 알람을 콜백 함수를 통해 값을 받아 출력했다.
    - 따라서 `setTimeout`은 비동기 함수이다.
- 다른 시각으로 보면 메인 함수 작업에 대해 `setTimeout` 함수는 자신의 타이머 작업을 수행하기 위해 메인 함수를 블락하지 않고 백그라운드에서 별도로 처리되었다.
    - 메인함수를 블락하지 않으니 바로 그 다음 콘솔 함수를 호출할 수 있는 것이다.
    - 따라서 `setTimeout`은 논블로킹 함수이다.

## 비동기 논블로킹과 콜백 함수

- 비동기 논블로킹이란 다른 작업의 결과를 기다리지 않고 병렬적으로 실행되는 방식이다.
    - 이 때, 다른 작업의 완료 여부나 결과에 대한 후처리를 위해 이용되는 방식이 콜백 함수이다.
- 엄밀히 따지면 콜백함수는 비동기 논블로킹을 구현하는 하나의 기술이지 개념이 아니다.
    - 콜백은 동기/비동기, 블로킹/논블로킹 개념과 직접적인 관련은 없다.

## 제어권

- 블로킹과 논블로킹은 호출된 함수가 호출한 함수에게 제어권을 바로 주느냐 안주느냐로 구분된다.
    - 제어권이 넘어가버리면 해당 스레드는 블로킹된다.

## 블로킹/논블로킹, 동기/비동기

### Sync-Blocking

![Untitled](https://velog.velcdn.com/images%2Fnittre%2Fpost%2Ff6212fee-ee42-4023-ae02-d2dc15eec46a%2Fimage.png)

- 함수 A는 함수 B의 리턴값을 필요로 한다. (동기)
- 그래서 제어권을 함수 B에게 넘겨주고, 함수 B가 실행을 완료해 리턴값과 제어권을 돌려줄 때까지 기다린다. (블로킹)
- 즉, **다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고(Blocking)**, **다른 작업의 완료 여부를 바로 받아 순차적으로 처리(Sync)**하는 방식이다.
- 코드가 순차적으로 실행되는 특성을 가지고 있기 때문에 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다.

### Sync-Nonblocking

![Untitled](https://velog.velcdn.com/images%2Fnittre%2Fpost%2Ffe5d1231-4c3c-4caf-bdd8-2287926e38ca%2Fimage.png)

- A함수는 B함수를 호출한다.
    - 이 때 **A함수는 B함수에게 제어권을 주지 않고 자신의 코드를 계속 실행**한다. (논블로킹)
- 하지만, A 함수는 B함수의 리턴값이 필요하기 때문에, **중간중간 B함수에게 함수 실행을 완료했는지 물어본다. (동기)**
- 즉, 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고(Non Blocking), 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행(Sync)하는 방식이다.

### Async-Nonblocking

![Untitled](https://velog.velcdn.com/images%2Fnittre%2Fpost%2Fb9566928-9a6b-4111-9cad-528daa45475d%2Fimage.png)

- A 함수는 B함수를 호출한다.
    - 이 때 제어권을 B함수에 주지 않고 자신이 계속 가지고 있는다. (논블로킹)
    - 따라서 B 함수를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행한다.
- B 함수를 호출할 때 콜백 함수를 함께 준다.
    - B 함수는 자신의 작업이 끝나면 A 함수가 준 콜백 함수를 실행한다. (비동기)
- 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고(Non Blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는(Async) 방식이다.
- 대표적으로 Node.js는 비동기 방식으로 파일을 읽거나 네트워크 요청을 보낼 때는 비동기 + 논블로킹 방식을 사용해 작업이 완료될 때까지 다른 작업을 수행할 수 있도록 한다.
    - 단, 코드 실행 시점을 늦춰주거나 순차적인 의존성이 있는 작업을 처리할 때는 동기 + 블로킹 방식을 사용해 작업의 순서와 타이밍을 제어할 수 있도록 한다.
- 작업량이 많거나 시간이 오래 걸리는 작업을 처리해야 하는 경우에 적합하다.

### Async-blocking

![Untitled](https://velog.velcdn.com/images%2Fnittre%2Fpost%2F9b6754f0-8721-4308-8a62-d884c7315d15%2Fimage.png)

- A함수는 B함수의 리턴 값에 신경쓰지 않고, 콜백 함수를 보낸다. (비동기)
    - 하지만, B함수의 작업에 관심 없음에도 불구하고, A함수는 B함수에 제어권을 넘긴다. (블로킹)
    - 따라서 A 함수는 자신과 관련 없는 B 함수의 작업이 끝날 때까지 기다려야 한다.

## 참고 자료

- [https://velog.io/@nittre/블로킹-Vs.-논블로킹-동기-Vs.-비동기](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0)
- [https://inpa.tistory.com/entry/👩‍💻-동기비동기-블로킹논블로킹-개념-정리](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)
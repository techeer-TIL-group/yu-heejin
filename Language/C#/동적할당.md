## C언어 동적 메모리 할당

- 동적 메모리 할당이란 컴퓨터 프로그래밍에서 실행중(런타임)에 사용할 메모리 공간을 할당하는 것을 의미한다.
- 컴파일러는 컴파일 시점에 소스 코드를 읽고 변수 타입들의 크기에 따라 메모리를 할당한다.
    - 이처럼 프로그램이 실행되기 전에 컴파일 시점에 소스 코드를 읽고 메모리 공간을 확보하는 것을 정적 할당(static allocation)이라고 한다.
- 이에 반해 동적 할당(dynamic allocation)이란 컴파일 타임이 아닌 프로그램이 실행되는 중인 런타임에 필요한 만큼에 메모리 공간을 확보하는 것을 의미한다.

## 동적 할당이 필요한 이유

- 메모리란 무한한 자원이 아니기 때문에 컴파일 타임에 메모리 공간을 많이 잡아버리면 남은 메모리 공간을 비효율적으로 사용하게 된다.
- 동적 할당이 필요한 이유는 그때그때 필요한 만큼의 메모리 공간을 확보하고, 다 사용한 경우 free 시켜줌으로써 메모리 공간을 해제하여 한정된 메모리 공간을 효율적으로 사용할 수 있기 때문이다.
- 이는 함수가 종료되거나 변수의 영역을 벗어나면 자동으로 메모리 해제가 이루어지는 스택과는 다르다.

### Heap 영역

- Heap이란 C언어나 자바와 같은 프로그래밍 환경에서 원시 자료형(primitive type)이 아닌 보다 큰 크기의 데이터를 담고자 동적으로 할당하는 메모리 공간을 지칭한다.
- C언어에서 말하는 동적 할당이란 힙 영역에 필요할 때마다 메모리 공간을 할당하고, 더 이상 필요하지 않을 경우 메모리를 해제해주는 과정을 의미한다.
- 운영체제가 직접 관리하는 힙 영역 내에 별도의 공간을 할당받고, 사용이 종료되면 사용자가 직접 메모리 해제를 해주어야 누수가 발생하지 않는다.

## 메모리 할당

- `malloc` 또는 calloc을 호출하면 힙 영역에 필요한 만큼의 메모리 공간을 확보하고 이후 반환 타입으로 해당 메모리 공간의 시작 위치를 포인터로 반환한다.
- 또한 할당된 메모리를 어떤 목적에 사용할지 함수에서 판단하기 어렵기 때문에 return 타입은 void * 형을 return하며, 반환받는 쪽에서 타입 캐스팅을 통해 사용해야 한다.

### malloc vs calloc

```csharp
int *arr=(int *)malloc(10*sizeof(int));
int *arr=(int *)calloc(10,sizeof(int));
```

- malloc은 매개변수로 입력한 크기 만큼 그대로 할당한다.
- calloc은 두번째 매개변수의 크기를 첫번째 매개변수 개수만큼을 할당해달라는 식으로 요청한다.
- 결론적으로 위 두 명령어 모두 같은 크기의 공간을 확보한다.
- 그러나 malloc의 경우 메모리 공간만 할당하므로, 초기화되지 않은 메모리 공간에는 쓰레기 값들이 들어있다.
- 반면에 calloc의 경우에는 할당 후 해당 메모리 공간을 0으로 초기화하기 때문에 성능 자체는 초기화시키지 않는 malloc이 더 낫다.

## 메모리 해제

- C언어에서는 free 함수를 통해 특정 주소의 메모리 공간을 해제할 수 있다.

## 메모리 재할당

```csharp
#include <stdio.h>
#include <stdlib.h> // stdlib.h 헤더 파일 필요

int main() {

    // 정수형 5칸 동적 할당(calloc)
    int *arr=(int*)calloc(5, sizeof(int));
    
    for (int i = 0; i < 5; i++)
        printf("%d\n", arr[i]);

    // 7칸으로 재할당 시도
    arr = (int*)realloc(arr, sizeof(int)*7);

    for (int i = 0; i < 7; i++)
          printf("%d\n", arr[i]);
          free(arr); // 사용 종료 시 free 필수!
}
```

- realloc함수를 이용해 메모리 공간 재할당이 가능하다.
- `realloc(동적 할당 변수, 변경된 할당 메모리의 총 크기)`

## C#에서의 동적 할당

> 결론적으로 C#은 Java처럼 CG가 동작하기 때문에 개발자가 직접 메모리를 할당하고 해제할 필요가 없다.
> 

C#에서는 C나 C++과 달리 메모리 관리가 자동으로 이루어집니다. C#은 .NET 프레임워크의 일부로 가비지 컬렉터(Garbage Collector, GC)를 사용하여 메모리를 자동으로 관리합니다. 이는 개발자가 직접 메모리를 할당하고 해제할 필요가 없음을 의미합니다.

C나 C++에서는 개발자가 **`malloc`** 또는 **`new`**를 사용하여 메모리를 할당하고, 사용이 끝난 후에는 **`free`**나 **`delete`**를 사용하여 해당 메모리를 직접 해제해야 합니다. 이 과정에서 메모리 누수(memory leaks)나 잘못된 메모리 접근(dangling pointers)과 같은 오류가 발생할 수 있습니다.

반면에, C#에서는 객체가 더 이상 사용되지 않을 때 가비지 컬렉터가 자동으로 메모리를 해제합니다. 가비지 컬렉터는 특정 시점에 애플리케이션의 메모리를 검사하여, 더 이상 참조되지 않는 객체를 찾아내고 메모리에서 제거합니다. 따라서 C# 개발자는 메모리 관리에 대해 걱정할 필요가 적어지며, 메모리 누수와 같은 문제를 방지할 수 있습니다.

하지만 가비지 컬렉터의 작동 시점을 예측하기 어렵기 때문에, 때때로 성능 최적화를 위해 메모리 사용을 세밀하게 관리해야 할 필요가 있을 수 있습니다. 또한, 외부 리소스(파일 핸들, 네트워크 연결 등)를 사용할 때는 **`IDisposable`** 인터페이스를 구현하여 **`Dispose`** 메서드에서 직접 자원을 해제해줘야 합니다. 이는 가비지 컬렉터가 자동으로 관리하지 않는 부분입니다.

## C# 동적 배열(Dynamic Array)

- 배열은 고정된 크기의 연속된 배열 요소들의 집합이므로 배열을 초기화할 때 총 배열 요소의 수를 미리 지정해야 한다.
- 그러나 경우에 따라 배열 요소가 몇개나 필요한지 알 수 없는 경우가 있고, 중간에 필요에 따라 배열을 확장해야 하는 경우도 발생한다.
- .NET은 이러한 동적 배열을 지원하는 클래스로 ArrayList와 List<T>가 있다.
    - 이러한 동적 배열 클래스들은 배열 확장이 필요한 경우, 내부적으로 배열 크기가 2배인 새로운 배열을 생성하고 모든 기존 배열 요소들을 새로운 배열에 복사한 후 가존 배열을 해제한다.
- 동적 배열의 시간 복잡도는 배열과 같이 인덱스를 통할 경우 O(1), 값으로 검색할 경우 O(n)을 갖는다.

### ArrayList 클래스

```csharp
ArrayList myList = new ArrayList();
myList.Add(90);
myList.Add(88);
myList.Add(75);

// int로 casting
int val = (int) myList[1]; 
```

- 모든 배열 요소가 object 타입인 Non-generic 동적 배열 클래스
- 단점으로 박싱 / 언박싱이 일어나게 된다.
- 배열 요소를 읽을 때 object를 리턴하기 때문에 일반적으로 원하는 타입으로 먼저 캐스팅한 후 사용한다.

### List<T> 클래스

```csharp
List<int> myList = new List<int>();
myList.Add(90);
myList.Add(88);
myList.Add(75);
int val = myList[1];
```

- 배열 요소가 T 타입은 제네릭으로서 동적 배열을 지원하는 클래스
- 내부적으로 배열을 가지고 있고, 동일한 타입의 데이터를 저장한다.
- 만약 미리 할당된 배열 크기가 부족하면 내부적으로 배열을 2배로 늘려 동적으로 배열을 확장한다.
- 캐스팅을 하지 않으며, 박싱/언박싱 문제도 일으키지 않는다.

## 참고 자료

- https://www.csharpstudy.com/DS/dynamic-array.aspx
- [https://velog.io/@saint6839/C언어-동적-메모리-할당-개념-잡기](https://velog.io/@saint6839/C%EC%96%B8%EC%96%B4-%EB%8F%99%EC%A0%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EA%B0%9C%EB%85%90-%EC%9E%A1%EA%B8%B0)
- https://jimmy-ai.tistory.com/376
- https://jie0025.tistory.com/190
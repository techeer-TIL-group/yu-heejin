## 동기(Synchronous)와 비동기(Asynchronous)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fdfe5d1d-dfb3-4ed1-95c7-0a6a33a4c18c/Untitled.png)

- 동기 방식은 **서버에서 요청을 보냈을 때 응답이 돌아와야 다음 동작을 수행**할 수 있다.
    - 즉, A 작업이 모두 진행될 때까지 B 작업은 대기해야 한다.
- 비동기 방식은 반대로 **요청을 보냈을 때 응답 상태와 상관없이 다음 동작을 수행**할 수 있다.
    - 즉, A 작업이 시작하고 동시에 B 작업도 실행할 수 있다.
    - A 작업은 결과 값이 나오는대로 출력된다.

### 비동기의 성능 이점

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3bc87d2-644f-484d-9883-a933300beb62/Untitled.png)

- 요청한 작업에 대해 완료 여부를 신경쓰지 않고 자신의 다음 작업을 수행한다는 것은, **시간이 느린 작업이 발생할 때 기다리지 않고 다른 작업을 처리하면서 동시에 처리하여 멀티 작업을 진행**할 수 있기 문이다.
- 여기서 ‘동시 처리’라는 개념은 두 개 이상의 작업이 동시에 실행되는 것을 의미한다.
    - 자바스크립트의 경우 비동기로 작업을 요청하면 브라우저에 내장된 멀티 스레드로 이루어진 Web API에 작업이 인가되어 매인 Call Stack과 작업이 동시에 처리되게 한다.
    - 쉽게 말해 작업을 백그라운드에 인가한다.
    - 대표적인 비동기 작업의 종류로는 애니매이션 실행, 네트워크 통신, 마우스 키보드 입력 등이 있다.

### 동기적 처리

```jsx
console.log('1st');
console.log('2nd');
console.log('3rd');
```

- 출력 결과는 순서대로 출력된다.
- 이처럼 코드가 위에서부터 아래로 내려오면서 하나가 끝나면 다음 코드가 실행되는 방식을 동기적 처리라고 한다.

### 비동기적 처리

```jsx
console.log('1st');

setTimeout(() => {
	console.log('2nd');
}, 0);

console.log('3rd');
```

- `setTimeout()` 메소드의 첫번째 인자는 콜백 함수를, 두번째 인자는 지연 시간이다.
- 두번째 인자가 0이기 때문에 바로 실행될 것이라 예상되지만, 다음과 같은 결과가 출력된다.
    
    ```jsx
    1st
    3rd
    2nd
    ```
    
- 이는 `setTimeout()` 메소드는 비동기적 API이기 때문이다.
    - 첫번째 줄에서 `console.log(’1st’);`를 실행하고 콘솔에 출력한다.
    - 두번째 줄에서 `setTimeout()` 메소드를 만나는데, **해당 메소드가 비동기적 메소드이기 때문에 이를 처리하는 다른 프로그램에 맡긴다.**
    - 다음줄에 3rd를 출력한다.
    - setTimeout() 메소드를 처리하는 프로그램은 **비동기적 API를 제외한 모든 코드가 실행된 이후 결과를 콘솔에 찍는다.**
        
        ```jsx
        console.log('1st');
        
        setTimeout(() => {
        	console.log('2nd');
        }, 0);
        
        console.log('3rd');
        console.log('4th');
        
        // 출력결과
        1st
        3rd
        4th
        2nd
        ```
        
        - **비동기적 코드의 실행 결과는 동기적 코드가 모두 실행되고 난 후 실행된다.**

## 블로킹(Blocking)과 논블로킹(Non-Blocking)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fbe34a23-77cf-4c3a-85a0-14b922fbee62/Untitled.png)

- 블로킹과 논블로킹은 **다른 요청의 작업을 처리하기 위해 현재 작업을 block(차단, 대기) 하느냐 아니냐의 유무를 나타내는 프로세스의 실행 방식**이다.
- 동기/비동기가 전체적인 작업에 대한 순차적인 흐름 유무라면, **블로킹/논블로킹은 전체적인 작업의 흐름 자체를 막냐 안막냐로 볼 수 있는 것이다.**
- 예를 들어 파일을 읽는 작업이 있을 때, 블로킹 방식으로 읽으면 파일을 다 읽을 때까지 대기하고, 논블로킹 방식으로 읽으면 파일을 다 읽지 않아도 다른 작업을 할 수 있다.

## 비동기와 논블로킹의 개념적 차이

- `setTimeout()` 함수는 **일반적으로 비동기 함수라고 하지만 동시에 논블로킹 함수**이기도 하다!
- 다음 코드는 `setTimeout()` 을 사용하여 1초 후에 Hello, world를 출력하는 비동기 논블로킹 코드의 예제이다.
    
    ```jsx
    console.log("시작");
    
    setTimeout(() => {
      console.log("1초 후에 실행됩니다!");
    }, 1000);
    
    console.log("끝");
    
    // 출력 결과
    시작
    끝
    1초 후에 실행됩니다!
    ```
    
    - 위에서 살펴본 것처럼 출력 순서와 정의된 코드 라인 순서가 맞지 않은 것은 `setTimeout()` 함수에 대해 **타이머 작업 완료 여부를 신경쓰지 않고 바로 다음 콘솔 작업을 수행했기 때문이다.**
        - 이러한 관점에서 보면 `setTimeout`은 비동기 함수이다.
    - 다른 시각으로 보면 메인 함수 작업에 대해 `setTimeout()`은 **자신의 타이머 작업을 수행하기 위해 메인 함수를 블락하지 않고 백그라운드에서 별도로 처리되었다.**
        - 메인 함수를 블락하지 않기 때문에 `setTimeout`함수를 호출하고 바로 그 다음 콘솔 함수를 호출한 것이다.
        - 따라서 논블로킹 함수라고도 할 수 있다.

## 비동기 논블로킹과 콜백 함수

- 비동기 논블로킹이란 **다른 작업의 결과를 기다리지 않고 병렬적으로 실행되는 방식**을 의미한다.
    - 이 때 **다른 작업의 완료 여부나 결과에 대한 후처리를 위해 이용되는 방식이 콜백 함수**이다.
- 콜백 함수는 비동기 논블로킹을 구현하는 하나의 기술이지 개념이 아니다.
    - 핵심은 비동기 논블로킹을 구현하는 기술은 콜백 외에 여러가지가 있다는 점이고, 콜백은 그 중 하나일 뿐이라는 것이지 동기/비동기, 블로킹/논블로킹 개념과 직접적인 연관은 없다.

## 제어권

- 제어권은 간단히 말해 **함수의 코드나 프로세스의 실행 흐름을 제어할 수 있는 권리**같은 것이다.
- 이 개념은 운영체제의 커널에서 따온 개념으로 I/O 동작에서 설명하는 부분이다.
    - 즉, 블로킹과 논블로킹은 **호출된 함수(callee)가 호출한 함수(caller)에게 제어권을 바로 주느냐 안주느냐로 구분**된다.
    - 제어권이 넘어가버리면 해당 스레드는 블로킹되게 된다.

### Blocking 방식으로 호출할 시 제어권 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19f1ca83-fa8d-4610-96c0-4d09c41ddb97/Untitled.png)

1. A 함수가 B 함수를 호출하면 B에게 제어권이 넘어간다.
2. 제어권을 넘겨받은 B는 함수를 실행한다.
3. 이 때 A는 B에게 제어권을 넘겨주었기 떄문에 A 함수 실행을 잠시 멈춘다. (Block)
4. B 함수가 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.
5. 제어권을 다시 받은 A 함수는 그 다음 작업을 실행한다.

### Non-Blocking 방식으로 호출할 시 제어권 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/01620bd9-09bb-428b-9870-54a001b35605/Untitled.png)

1. A 함수가 B 함수를 호출한다.
2. 호출된 B함수는 실행되지만, 제어권은 그대로 가지고 있기 때문에 B 함수를 호출한 이후에도 자신의 코드를 계속 실행한다.

## 동기/비동기 + 블로킹/논블로킹 조합

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d4ed4380-8c82-455c-b3b1-2893f69fef7c/Untitled.png)

### Sync Blocking (동기 블로킹)

- 다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고(Blocking) 다른 작업의 완료 여부를 바로 받아 순차적으로 처리(Sync)하는 방식이다.
- 다른 작업의 결과가 자신의 작업에 영향을 주는 경우 활용할 수 있다.
- 코드가 순차적으로 실행되는 특성을 가지고 있기 때문에 일반적으로 작업이 간단한 경우에 사용한다.
- 작업량이 많거나 시간이 오래 걸리는 작업을 처리해야하는 경우에는 독이된다.

### Async Non-Blocking (비동기 논블로킹)

- 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고(Non Blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는(Async) 방식이다.
- 다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우 활용할 수 있다.
- 해당 방식은 작업량이 많거나 시간이 오래 걸리는 작업을 처리해야 하는 경우 적합하다.

### Sync Non-Blocking (동기 논블로킹)

- 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고(Non Blocking), 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행하는(Sync) 방식이다.

### Async Blocking (비동기 블로킹)

- 다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리며(Blocking), 다른 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는 방식이다.

## 참고 자료

- [https://velog.io/@daybreak/동기-비동기-처리](https://velog.io/@daybreak/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC)
- [https://inpa.tistory.com/entry/👩‍💻-동기비동기-블로킹논블로킹-개념-정리](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)
<aside>
💡 일반적으로 VM을 설치한 OS를 Host OS, 가상 머신에 설치한 OS를 Guest OS라고 한다.

</aside>

## ✏️ 가상 머신(VM)과 컨테이너

<img width="698" alt="스크린샷 2023-09-12 오후 12 10 08" src="https://github.com/yu-heejin/coding-test/assets/96467030/05e7442e-d0c7-44a3-b595-171f304a4396">

### 가상 머신(VM)

> 하나의 Host OS위에 하이퍼바이저 기법을 통해 독립적인 OS를 실행하는 형태
> 
- 가상화 기술 중 하나인 가상 머신(Virtual Machine)은 하이퍼바이저(Hypervisor)를 이용해 **여러 운영체제를 하나의 호스트에서 생성하여 사용**하는 방식 (쉽게 말해 컴퓨터 전체 시스템을 소프트웨어로 구현)
    - 하이퍼바이저란 호스트 컴퓨터(실제 컴퓨터)에서 다수의 OS를 동시에 실행하기 위한 플랫폼, 가상 머신 매니저라고도 한다. ([하이퍼바이저](https://dora-guide.com/%ED%95%98%EC%9D%B4%ED%8D%BC%EB%B0%94%EC%9D%B4%EC%A0%80/))
- 여러 운영체제는 **가상 머신**이라는 단위로 구분되고, 각 가상머신에 Ubuntu, CentOS 등의 운영체제를 설치하여 사용한다. (AWS EC2를 떠올리시면 쉬울거예요.)
- 각 게스트 운영체제는 **다른 게스트 운영체제와 완전히 독립된 공간과 시스템 자원을 할당** 받아 사용 (하드웨어 추상화)
    - 논리적으로 구분된 공간에서 독립된 가상의 하드웨어를 받은 **VM들은 서로에게 어떠한 영향도 끼치지 않는다. (완전 다른 컴퓨터처럼)**

### 컨테이너(Container)

> 하나의 Host OS위에 별도로 격리된 환경에서 프로세스를 실행하도록 하는 가상화 방식 (마치 프로그램 패키지화와 같음)
> 
- VM과 달리 Application 계층의 추상화
- 컨테이너는 애플리케이션 코드, 런타임, 시스템 도구, 라이브러리 및 구성을 하나의 인스턴스에 패키징하는 기본적인 방법을 제공한다.
    - 개발 환경 통일이 가능하다.
- VM과 달리 **컨테이너는 하드웨어에 설치된 운영 체제 하나를 공유한다.** (Host OS에 종속적)
- 하나의 OS 위에서 자원을 공유하기 때문에 VM에 비해 공간을 적게 차지하며, 이미지만 있으면 운영체제에 상관없이 가볍기 때문에 배포시 많이 사용한다.
- 이식성이 뛰어나지만 가상 머신에 비해 보안의 문제가 있다고 한다. → docker secret을 활용할 수 있음

## ✏️ Docker 기초 개념

<img width="718" alt="스크린샷 2023-09-12 오후 12 09 50" src="https://github.com/yu-heejin/coding-test/assets/96467030/055ad2f0-93eb-431b-8bc4-63cbbce9e3fb">

- 리눅스 컨테이너 기반 오픈소스 가상화 플랫폼으로, 응용프로그램들을 프로세스 격리 기술들을 사용해 컨테이너로 실행하고 관리한다.
- 다양한 프로그램들과 실행 환경을 컨테이너로 규격화시켜 프로그램의 배포 및 관리를 단순화
- 프로그램의 코드뿐만 아니라 실행에 필요한 모든 dependency도 컨테이너에 담기 때문에 다른 환경에서도 빠르게 애플리케이션을 실행할 수 있다.

## ✏️ React 배포 예시 코드

```docker
# 베이스 이미지 지정
# 베이스 이미지 없이 태초부터 만드는 방법이 있으나, 기초 단계에서는 고려하지 않음
# 베이스이미지:버전(태그)
FROM node:18

# RUN, COPY 등이 이루어지는 기본 디렉토리 설정
WORKDIR /frontend/

# 필요한 파일을 컨테이너에 복사
# package*.json을 먼저 복사하는 이유는 캐싱 문제 때문
COPY package*.json /frontend/

# Docker 이미지를 빌드하는 순간에 실행되는 명령어
# 주로 라이브러리 설치 시 많이 사용한다.
RUN npm install

COPY . .

# RUN과 달리 이미지로부터 컨테이너를 생성하여 최초로 실행할 때 수행된다.
CMD ["npm", "start"]
```

- `Dockerfile.prod`, `Dockerfile.dev` 등으로 구분해서 코드를 작성할 수도 있음

## ✏️ 실행하기

```bash
# -t 옵션으로 이미지 이름 지정
docker build -t {image-name} .

# -p: 포트 지정
# --name: 컨테이너 이미지 이름 지정
docker run -p 3000:3000 --name {container-name} {image-name}
```

## ✏️ 배포 시 주의사항

- 배포 시 일반적으로 Docker hub에 자신의 프로젝트를 빌드해서 `push`후, 운영 서버에 `pull`하는 경우가 일반적이다.
- 이 때 Github Actions와 같은 자동화 배포를 사용하면 문제가 없지만 (리눅스 내에서 빌드하도록 설정), **윈도우나 맥과 같은 로컬 환경에서 빌드 시 리눅스 환경에서 사용할 수 없다는 문제가 있다.**
    - 컨테이너는 OS 자체를 담지 않기 때문이다. → Host OS에 종속적이기 때문
- 빌드 시 아래 옵션을 붙여주면 정상적으로 동작할 수 있다.
    
    ```bash
    docker build **--platform linux/amd64** -t {image-name} .
    ```
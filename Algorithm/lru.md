## 페이지 교체 알고리즘

- 페이징 기법으로 메모리를 관리하는 운영체제에서 페이지 부재 발생 시, **새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어떤 것과 교체할지 결정하는 방법**

### FIFO

- 페이지가 **주기억장치에 적재된 시간을 기준**으로 교체될 페이지를 선정하는 기법
- 중요한 페이지가 오래 있었다는 이유만으로 교체되는 불합리가 있을 수 있다.

### LFU

- **가장 적은 횟수**를 참조하는 페이지를 교체
- 참조될 가능성이 많음에도 불구하고 횟수에 의한 방법이므로 최근에 사용된 프로그램을 교체시킬 가능성이 있고, 해당 횟수를 증가시키므로 오버헤드가 발생한다.

### LRU

- **가장 오랫동안 참조되지 않은 페이지**를 교체
- 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 시간을 기록해야한다.
    - 오버헤드가 발생할 수 있다.

## LRU(Least Recently Used) 알고리즘

- 가장 오랫동안 참조되지 않은 페이지를 교체하는 방법

### 장점

- 빠른 액세스: 가장 최근에 사용한 아이템부터 가장 이전에 사용한 아이템까지 정렬되기 때문에 아이템에 접근할 경우 `O(n)`의 시간 복잡도를 가진다.
- 빠른 업데이트: 하나의 아이템에 엑세스할 때마다 업데이트 되며, O(n)의 시간 복잡도를 가진다.

### 단점

- 많은 공간을 차지한다.
    - n개의 아이템을 저장하는 LRU는 N의 크기를 가지는 1개의 Linked List(queue)와 이를 추적하기 위한 n의 크기를 가지는 1개의 Hash Map이 필요하다.
    - 이는 `O(n)`의 복잡도를 가지지만 2개의 데이터 구조를 사용해야한다는 단점이 있다.

## 예시

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F998933375C7F78A428)

- input: 123145
- 4초: 1이 재참조 되었기 때문에 가장 오랫동안 참조되지 않은 순으로 저장된 순서를 변경한다.
- 6초: 캐시 사이즈가 가득차 5가 들어갈 수 없으므로, 가장 오랫동안 참조되지 않은 2를 제거한 후 저장한다.

## 참고 자료

- [https://velog.io/@ddyy094/LRULeast-Recently-Used-알고리즘-이란](https://velog.io/@ddyy094/LRULeast-Recently-Used-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%EB%9E%80)
- https://j2wooooo.tistory.com/121
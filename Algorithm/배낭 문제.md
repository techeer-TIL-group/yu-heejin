## 배낭 문제(Knapsack Problem)

- 담을 수 있는 최대 무게가 정해진 배낭이 있고, 각각의 무게와 가치가 주어진 물건들이 주어졌을 때, **배낭에 담은 물건들의 가치가 최대가 되도록 물건을 고르는 방법**

### 문제 유형

- 물건을 쪼갤 수 있어 무게나 가치가 소수점 단위로 나뉘는 문제
- 물건을 쪼갤 수 없어 무게와 가치가 무조건 정수 형태를 가지는 문제

## DP를 활용한 배낭 문제 풀기

[12865번: 평범한 배낭](https://www.acmicpc.net/problem/12865)

> 최대 무게 7kg, 아이템 리스트가 아래와 같다고 하자.
> 
> 
> ```sql
> 각각을 [무게, 가치]라 할 때
> 
> [6, 13] [4, 8] [3, 6] [5, 12]
> ```
> 
1. 2차원 배열을 만들고, 행을 가방의 최대 무게, 열을 각 아이템 번호로 지정한다. (행과 열을 바꾸어도 된다.)
    
    ```sql
    // dp[i][j] = 배낭의 최대 무게가 i이고 j번째 아이템까지 살펴봤을 때의 최대 가치
    int[][] dp = new int[k + 1][n + 1];      // {최대 무게, 아이템}
    ```
    
    |  | 0 | 1 [6, 13] | 2 [4, 8] | 3 [3, 6] | 4 [5, 12] |
    | --- | --- | --- | --- | --- | --- |
    | 0 |  |  |  |  |  |
    | 1 |  |  |  |  |  |
    | 2 |  |  |  |  |  |
    | 3 |  |  |  |  |  |
    | 4 |  |  |  |  |  |
    | 5 |  |  |  |  |  |
    | 6 |  |  |  |  |  |
    | 7 |  |  |  |  |  |
2. 배낭의 최대 무게가 0일 경우 / 물건 인덱스가 0번인 경우 아무 문제도 넣을 수 없으니 가치도 0이다.
    
    
    |  | 0 | 1 [6, 13] | 2 [4, 8] | 3 [3, 6] | 4 [5, 12] |
    | --- | --- | --- | --- | --- | --- |
    | 0 | 0 | 0 | 0 | 0 | 0 |
    | 1 | 0 |  |  |  |  |
    | 2 | 0 |  |  |  |  |
    | 3 | 0 |  |  |  |  |
    | 4 | 0 |  |  |  |  |
    | 5 | 0 |  |  |  |  |
    | 6 | 0 |  |  |  |  |
    | 7 | 0 |  |  |  |  |
3. 반복하면서 최대 무게보다 작은 경우 가방에 물건을 넣는다.
    
    
    |  | 0 | 1 [6, 13] | 2 [4, 8] | 3 [3, 6] | 4 [5, 12] |
    | --- | --- | --- | --- | --- | --- |
    | 0 | 0 | 0 | 0 | 0 | 0 |
    | 1 | 0 | 0 | 0 | 0 | 0 |
    | 2 | 0 | 0 | 0 | 0 | 0 |
    | 3 | 0 | 0 | 0 | 6 | 6 |
    | 4 | 0 |  |  |  |  |
    | 5 | 0 |  |  |  |  |
    | 6 | 0 |  |  |  |  |
    | 7 | 0 |  |  |  |  |
    - 4번 아이템의 경우, 무게가 5 이기 때문에 자기 자신은 가방에 넣을 수 없다.
        - 이 경우, 가방에 아무것도 넣지 않은 결과보다 3번 아이템을 넣었을 때 가치가 더 크기 때문에 앞의 가치 6을 넣어준다.
        - 즉, 자기 자신은 넣지 않고, 앞 아이템을 넣었을 때 가치를 저장한다.
4. 계속 반복하다가 중간에 두 가지 경우로 나뉠 때가 있다.
    
    
    |  | 0 | 1 [6, 13] | 2 [4, 8] | 3 [3, 6] | 4 [5, 12] |
    | --- | --- | --- | --- | --- | --- |
    | 0 | 0 | 0 | 0 | 0 | 0 |
    | 1 | 0 | 0 | 0 | 0 | 0 |
    | 2 | 0 | 0 | 0 | 0 | 0 |
    | 3 | 0 | 0 | 0 | 6 | 6 |
    | 4 | 0 | 0 | 8 | ⭐️ |  |
    | 5 | 0 |  |  |  |  |
    | 6 | 0 |  |  |  |  |
    | 7 | 0 |  |  |  |  |
    - ⭐️ 위치에서는 다음 두 가지를 고려해볼 수 있다.
        1. 현재 아이템을 담지 않는 경우
        2. 현재 아이템을 담는 경우
    - 현재 배낭의 최대 무게가 4, 앞에서 2번 아이템을 담은 경우가 가치가 제일 큰 경우를 생각해보자.
        - 현재 아이템을 넣는 경우, 가장 큰 가치를 내는 방법은 (최대 무게) - (현재 무게)의 결과의 가치이다.
            - 무슨 말이냐면 현재 물건을 넣었을 때, **남은 무게만큼 물건을 넣으면 가치의 최댓값이 나온다는 것이다.**
        - **현재 아이템을 넣지 않는 경우, 이전 값을 그대로 유지하는 것이 최댓값이다.**
    - 따라서 dp 공식은 아래와 같다.
        
        ```java
        dp[i][j] = Math.max(dp[i][j - 1], dp[before][j - 1] + things[j][1]);
        ```
        
        - `dp[i][j - 1]`: 현재 아이템을 넣지 않는 경우
        - `dp[before][j - 1] + things[j][1]`: 현재 아이템을 넣었을 때 남은 무게만큼의 가치와 현재 아이템의 가치를 더한 값
            - 이 때 `dp[before][j - 1]`에서 j - 1인 이유는, **현재 위치에서의 해당 무게(여기서는 최대 무게 - 현재 무게)일 때의 가치를 찾기 위함이다.**

전체 코드는 아래와 같다.

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String args[]) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        String[] input = br.readLine().split(" ");
        
        int n = Integer.parseInt(input[0]);
        int k = Integer.parseInt(input[1]);
        
        int[][] things = new int[n + 1][2];      // {물건의 무게, 가치}
        
        for (int i = 1; i <= n; i++) {
            input = br.readLine().split(" ");
            
            things[i][0] = Integer.parseInt(input[0]);     // w
            things[i][1] = Integer.parseInt(input[1]);     // v
        }
        
        // dp[i][j] = 배낭의 최대 무게가 i이고 j번째 아이템까지 살펴봤을 때의 최대 가치
        int[][] dp = new int[k + 1][n + 1];      // {최대 무게, 아이템}
        
        for (int i = 1; i <= k; i++) {
            for (int j = 1; j <= n; j++) {
                if (things[j][0] > i) {
                    // 해당 물건을 담을 수 없는 경우 이전 무게의 가치
                    dp[i][j] = dp[i][j - 1];
                } else {
                    // 해당 물건을 담을 수 있는 경우
                    // 해당 물건을 넣은 경우의 가치와 해당 물건을 넣지 않았을 경우의 가치 비교
                    // 해당 물건을 넣은 경우 남은 무게
                    int before = i - things[j][0];
                    dp[i][j] = Math.max(dp[i][j - 1], dp[before][j - 1] + things[j][1]);
                }
            }
        }
        
        System.out.println(dp[k][n]);
    }
}
```

## 참고 자료

- https://gsmesie692.tistory.com/113
- https://propercoding.tistory.com/50
- [https://velog.io/@js43o/백준-12865번-평범한-배낭](https://velog.io/@js43o/%EB%B0%B1%EC%A4%80-12865%EB%B2%88-%ED%8F%89%EB%B2%94%ED%95%9C-%EB%B0%B0%EB%82%AD)
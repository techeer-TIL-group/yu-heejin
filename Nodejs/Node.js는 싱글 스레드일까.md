## 프로세스와 스레드 (Process & Thread)

- 프로세스(process)는 프로그램이 실행되는 즉시 CPU로부터 할당받는 자원 영역이다. (메모리 등)
- 스레드(thread)는 프로세스 내에서 실행되는 여러 흐름의 단위이며, 프로세스가 할당받은 시스템 자원(CPU 시간, 메모리 영역 등)을 이용하는 실행 단위이다.
    - 스레드는 프로세스의 메모리 영역인 Code, Data, BSS, Heap, Stack에 접근하여 활용하게 된다.

### 프로세스의 메모리

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcDTyMh%2Fbtrd3aQJHBd%2FH6tapPbcfzpeKZYT0pFAa0%2Fimg.jpg)

- 프로세스의 메모리는 크게 Code, Data, BSS, Heap, Stack의 영역으로 나뉜다.

### Code

- 가장 하단에 위치한 영역이며, 작성한 기계어 또는 코드가 들어간다.
- 함수, 제어문, 상수 등이 들어간다.
- Read-only 영역이며, 컴파일러가 만든 코드라고 봐도 무방하다.

### Data

- 전역변수, 정적변수, 배열, 구조체 등이 저장되는 공간이다.
- 초기화(initialized)된 데이터가 저장되는 공간이다.
    - 즉, 초기값이 있는 static 변수가 들어간다.

### BSS(Block-stated Symbol)

- 전역변수, 정적변수, 배열, 구조체 등이 저장되는 공간이다.
- 초기화되지 않은 (초기값이 없는) 데이터가 저장된다.
- *Code, Data, BSS 모두 정적인 영역이며, compile time에 크기가 결정되어 이후에 변동되지 않는다.*
- *또한, 프로세스가 종료될 때까지 계속 작동한다.*

### Heap

- 프로그래머가 동적으로 사용하는 영역으로, 동적 객체 데이터의 할당 또는 반환이 이루어지는 영역이다.

### Stack

- 함수가 포함되어 있고, 함수 내의 지역변수, 매개변수 등이 저장되어 있는, 프로그램이 자동으로 사용하는 임시 메모리
- LIFO(선입후출) 정책을 사용하여, 함수 호출 시 생성되고 함수 종료시 반환된다.
- *Heap의 영역이 증가하여 Stack 영역을 침범하는 Heap Overflow의 상황이 되거나, Stack의 영역이 증가하여 Heap의 영역을 침범하는 Stack Overflow의 상황이 될 때 사용되는 메모리의 자유 영역 또한 존재한다.*
- *프로세스의 메모리 속도는 Stack > Data > Code > Heap 순으로 빠르다.*

## Single, Multi-thread

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F9amAs%2Fbtrd66fZwdP%2FkLUiT9ig29MsiGi1KSDXUk%2Fimg.png)

![Register는 Stack의 최상단 값의 주소를 추적하는 포인터이다.](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAUiEl%2Fbtrea16jmlN%2FvNfyMMmVnBHtDvTi7FHk3k%2Fimg.png)

Register는 Stack의 최상단 값의 주소를 추적하는 포인터이다.

- 전통적인 컴퓨터는 전부 Single Thread로 이루어졌지만, 점차 Multi Thread 프로세싱이 가능한 컴퓨터가 많아지고 있다.
- 참고로 코어 수 하나 당 하나의 스레드를 실행할 수 있다.
    - 만약 코어가 2개인 CPU에서 스레드가 2개인 프로세스가 실행되면 2개의 스레드는 병렬적으로 실행되지만, 4개의 스레드가 실행되면 하나의 코어당 2개의 스레드를 담당하여 Context-switching을 통해 모두 병렬적으로 실행되는 것처럼 보이게끔 한다.

### Single Thread

- 하나의 프로세스에서 하나의 스레드를 실행하므로, 프로세스 내의 작업을 순차적으로 실행한다.
- 유저와 상호작용하는 애플리케이션의 경우, 한 가지 작업이 끝난 뒤에야 다음 작업으로 이동하기 때문에 유저가 원하는 작업 수행이 빠르게 이루어지지 않을 수 있다. (low-responsiveness)

### Multi Thread

- 하나의 프로세스 내에 여러 개의 스레드가 실행된다.
- 각각의 스레드가 다른 작업을 할당받으므로, 프로세스가 병렬적으로 여러 작업을 동시에 수행할 수 있다.
- Multi Thread 는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
- 따라서 Heap 메모리는 서로 동시에 읽고 쓸 수 있으며, 한 스레드가 자원을 변경하면 다른 이웃 스레드도 그 결과를 즉시 볼 수 있다.
- 여러개의 스레드가 동일한 메모리 주소를 활용하면서 작업을 여러 개 수행하기 때문에, 메모리 사용이 효율적이다.

## Javascript는 싱글 스레드인가?

- 자바스크립트를 작동시키는 것은 V8엔진이며, V8엔진은 Call Stack과 Memory Heap으로 구성되어 있다.
- 이 V8 엔진 덕분에 자바스크립트는 브라우저 내부에서도, 외부에서도 동작할 수 있게 된다.
- V8 엔진과 런타임이 만나면 이벤트 루프가 작동하게 된다.
    - 이벤트 루프는 비동기 처리를 가능하게 해주는 일종의 시스템이다.
- **이벤트 루프는 싱글 스레드로 작동**하기 때문에 **자바스크립트를 싱글 스레드 언어**라고 부른다.
    - 이는 **자바스크립트 코드가 순차적으로 실행**된다는 의미이다.
    - 즉, **이전 라인에 작성된 코드 실행이 완료되지 않은 상태에서 다음 코드 실행 단계로 넘어가지 않는다.**
- 하지만, 가장 중요한 것은 **자바스크립트는 Node 나 웹 브라우저와 같은 멀티 스레딩이 가능한 환경에서 실행된다.**
    - 따라서, **자바스크립트(엔진)은 싱글 스레드이지만, 자바스크립트를 실행하는 런타임은 완벽한 싱글 스레드가 아니라고 할 수 있다.**

## Nodejs는 멀티 스레드인가?

- Node 역시 하나의 프로그램이기 때문에 실행 즉시 하나의 독립된 프로세스가 되어 CPU로부터 리소스를 할당받는다.
- Node에서 자바스크립트를 실행하면 **콜백을 통해 여러 개의 비동기 함수를 실행**할 수 있으며, **fs.readfile 또는 DNS read와 같은 작업들도 수행**할 수 있게 된다.
- 하지만, 이러한 작업의 문제점은 **이벤트 루프에 큰 부담을 주어 결과적으로 애플리케이션의 성능을 줄일 수 있다.**
    - 이를 해결하기 위해 **Nodejs는 uvlib라는 C library를 사용하기 시작했고, 이 라이브러리는 멀티 스레딩을 지원한다.**
- 결론적으로, **NodeJS는 두 가지 스레드**로 구성되어 있다.
    1. 이벤트 루프(메인 스레드)
    2. Thread Pool(미리 생성된 비어있는 스레드 그룹)
        1. 스레드 풀의 크기를 미리 정해놓으면 반복적인 스레드 생성/삭제 절차를 줄임으로써 프로세스의 성능을 개선할 수 있다.
        2. 노드의 스레드 풀 기본값은 4개이다.
- **NodeJS는 이벤트 루프에서 작동하다가, fs나 해싱 등의 작업이 필요한 경우 이 작업을 Thread pool로 던져주어 새로운 thread를 사용한다.**

### uvlib

- I/O-intensive 작업과 CPU-intensive 작업을 지원한다.
    - I/O-intensive: DNS, FIle System 관련 내용이다.
    - CPU-intensive: Crypto, Zlib 관련 내용이다.

### Nodejs가 uvlib를 사용하여 새로운 스레드를 사용하는 상황

1. DNS 쿼리를 할 때
    - Host의 ip를 읽어야하는 상황에서는 메인 스레드인 이벤트 루프를 사용하지 않고 새로운 스레드를 만들어 작업을 수행한다.
    - Fetch API 등을 활용할 때가 이에 해당한다.
2. File System에 접근할 때
    - Async(비동기) file system 작업을 할 때 이벤트 루프에서 자체적으로 새로운 스레드로 해당 작업을 넘긴다.
    - 주의할 점은, **readfilesync와 같은 동기 함수는 새로운 스레드가 아닌 이벤트 루프에서 실행된다는 사실**이다.
3. Crypto, Zlip
    - crypto를 활용한 암호화나 해싱 작업 또한 이벤트 루프가 아닌 스레드를 활용한다.
    - Zlip: 코드 내에서 무언가 압축할 때 역시 스레드를 활용한다.

### 중요한 point

- res.end 등과 같이 **networking 관련 작업은 항상 메인 스레드인 이벤트 루프를 활용한다.**
- 서버의 코드를 작성할 때 **해당 코드의 작업이 이벤트 루프에서 이루어지는지, 다른 스레드에서 이루어지는 판단하는 것은 매우 중요하다.**
    - 때에 따라서 이벤트 루프에서 진행되는 작업으로 인해 영영 응답(response)을 받지 못할 수도 있기 때문이다.

## 정리

- **Nodejs는 기본적으로 Javascript의 이벤트 루프를 메인 스레드로 활용하기 때문에 싱글 스레드이다.**
- 하지만 기본 작업 외 특정 작업을 수행할 때 **추가 스레드가 필요한 경우에는 새로운 스레드를 생성하여 실행할 수 있는 멀티 스레드 프로세스** 이기도 하다.

## 참고 자료

- [https://haeunyah.tistory.com/81](https://haeunyah.tistory.com/81)
